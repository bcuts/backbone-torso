<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/behaviors/DataBehavior.js - backbone-torso</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="backbone-torso" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.6.18</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Behavior.html">Behavior</a></li>
                                <li><a href="../classes/Cell.html">Cell</a></li>
                                <li><a href="../classes/Collection.html">Collection</a></li>
                                <li><a href="../classes/Events.html">Events</a></li>
                                <li><a href="../classes/FormModel.html">FormModel</a></li>
                                <li><a href="../classes/FormView.html">FormView</a></li>
                                <li><a href="../classes/history.html">history</a></li>
                                <li><a href="../classes/ListView.html">ListView</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NestedModel.html">NestedModel</a></li>
                                <li><a href="../classes/Router.html">Router</a></li>
                                <li><a href="../classes/ServiceCell.html">ServiceCell</a></li>
                                <li><a href="../classes/Torso.html">Torso</a></li>
                                <li><a href="../classes/Torso.behaviors.DataBehavior.html">Torso.behaviors.DataBehavior</a></li>
                                <li><a href="../classes/Torso.behaviors.DataBehavior.Data.html">Torso.behaviors.DataBehavior.Data</a></li>
                                <li><a href="../classes/Torso.Mixins.cacheMixin.html">Torso.Mixins.cacheMixin</a></li>
                                <li><a href="../classes/Torso.Mixins.cellMixin.html">Torso.Mixins.cellMixin</a></li>
                                <li><a href="../classes/Torso.Mixins.loadingMixin.html">Torso.Mixins.loadingMixin</a></li>
                                <li><a href="../classes/Torso.Mixins.pollingMixin.html">Torso.Mixins.pollingMixin</a></li>
                                <li><a href="../classes/Torso.Utils.handlebarsUtils.html">Torso.Utils.handlebarsUtils</a></li>
                                <li><a href="../classes/Torso.Utils.stickitUtils.html">Torso.Utils.stickitUtils</a></li>
                                <li><a href="../classes/Torso.Utils.templateRenderer.html">Torso.Utils.templateRenderer</a></li>
                                <li><a href="../classes/Torso.validation.html">Torso.validation</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Torso.html">Torso</a></li>
                                <li><a href="../modules/Torso.behaviors.html">Torso.behaviors</a></li>
                                <li><a href="../modules/Torso.behaviors.DataBehavior.html">Torso.behaviors.DataBehavior</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: modules/behaviors/DataBehavior.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(root, factory) {
  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
    define([&#x27;underscore&#x27;, &#x27;jquery&#x27;, &#x27;../Behavior&#x27;, &#x27;../Collection&#x27;, &#x27;../Events&#x27;], factory);
  } else if (typeof exports === &#x27;object&#x27;) {
    var _ = require(&#x27;underscore&#x27;);
    var $ = require(&#x27;jquery&#x27;);
    var Behavior = require(&#x27;../Behavior&#x27;);
    var Collection = require(&#x27;../Collection&#x27;);
    var Events = require(&#x27;../Events&#x27;);
    module.exports = factory(_, $, Behavior, Collection, Events);
  } else {
    root.Torso = root.Torso || {};
    root.Torso.behaviors = root.Torso.behaviors || {};
    root.Torso.behaviors.DataBehavior = factory(root._, root.$, root.Torso.Behavior, root.Torso.Collection, root.Torso.Events);
  }
}(this, function(_, $, Behavior, Collection, Events) {
  &#x27;use strict&#x27;;

  /**
   * Converts string or number values into an array with a single string or number item.
   * If the input is not a string, number or array then undefined is returned.
   * This is a private helper method used internally by this behavior and is not exposed in any way.
   * @param ids {String|Number|String[]|Number[]} the ids to convert.
   * @return {String[]|Number[]} an array of strings or numbers.
   * @private
   */
  function normalizeIds(ids) {
    if (_.isArray(ids)) {
      // remove any nesting of arrays - it is assumed that the resulting ids will be simple string or number values.
      ids = _.flatten(ids);
      // remove any duplicate ids.
      return _.uniq(ids);
    } else if (_.isString(ids) || _.isNumber(ids)) {
      // individual id - convert to array for consistency.
      return [ids];
    }
  }

  /**
   * Behaviors defined in Torso.
   * @module Torso.behaviors
   * @namespace Torso.behaviors
   */

  /**
   * This behavior implements simplified interaction with data sources (i.e. TorsoCollection).
   * This behavior manages re-rendering when data changes and automatically adding the returned data to the view&#x27;s context.
   * This behavior also manages dependencies between data and other objects to allow intelligent re-fetching when data changes.
   *
   * Example Configuration on the view:
   *
   *     TorsoView.extend({
   *       behaviors: {
   *         demographics: {
   *           behavior: TorsoDataBehavior,
   *           cache: require(&#x27;./demographicsCacheCollection&#x27;),
   *           returnSingleResult: true,
   *           id: { property: &#x27;_patientVecnaId&#x27; }
   *         }
   *       }
   *     }
   *
   * Any options for this behavior can also be configured directly on it using the same extension mechanism as other
   * Backbone or Torso objects.
   *
   * Example configuration by extension:
   *
   *     var AppointmentDataBehavior = DataBehavior.extend({
   *       cache: require(&#x27;./appointmentCacheCollection&#x27;),
   *       id: { property: &#x27;_appointmentExternalId&#x27; },
   *       returnSingleResult: true,
   *       alwaysFetch: true
   *     });
   *
   * Ways to cause this data behavior to refresh the data.  Ids are retrieved from the idsContainer whenever a refresh of data is requested.
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).pull()__ - Any ids that are already in the cache are added immediately.
   *                                                       Any that are not already in the cache are fetched as a single batch of ids.
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).fetch()__ - Regardless of the cache state all ids identified by this behavior are fetched from the server.
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).retrieve()__ - Will either fetch or pull based on the current value of &#x27;alwaysFetch&#x27;.
   *                                                           Defaults to pull (if alwaysFetch is not explicitly set).
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).trigger(&#x27;ids-container-updated&#x27;)__ - this is a way to indicate that the id container changed
   *                                                                                 which means the id listeners should be rebound and data should be refreshed.
   *  * __idsContainer.trigger(&#x27;change:&lt;idPropertyName&gt;&#x27;)__ - This is the change event that is already emitted by Cell-like objects when their properties change.
   *  * __idsContainer.trigger(&#x27;fetched:ids&#x27;)__ - This indicates that the ids have been fetched for the first time (when a change event may not be fired) and is used
   *                                              mainly to chain data behaviors together (this event is also emitted by this behavior whenever a fetch or pull completes).
   *
   * Ways to get properties from the data in this behavior:
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).data.toJSON()__ - Either array of data if returnSingleResult is false (default),
   *                                                              Or the object data directly if returnSingleResult is true.
   *  * __view.getBehavior(&#x27;thisBehaviorAlias&#x27;).data.toJSON(&#x27;some.data.property&#x27;)__ - returns just that property of the result or undefined if it hasn&#x27;t been fetched or doesn&#x27;t exist.
   *                                                                                  If returnSingleResult is false then an array of values for that object is returned
   *                                                                                  This is equivalent to _.pluck(view.getBehavior(&#x27;thisBehaviorAlias&#x27;).toJSON(), &#x27;some.data.property&#x27;).
   *
   *   The context generated by &#x60;view.prepare()&#x60; will contain all of the data associated with this view namespaced by the behavior&#x27;s alias .data on the view.
   *   This the same data as returned by &#x60;view.getBehavior(&#x27;thisBehaviorAlias&#x27;).data.toJSON()&#x60;.
   *
   *     View.extend({
   *       behaviors: {
   *         thisBehaviorAlias: {
   *           behavior: ThisBehaviorClass
   *         }
   *       }
   *     });
   *
   *   result from prepare:
   *
   *     {
   *       ...,
   *       thisBehaviorAlias: {
   *         ...,
   *         data: &lt;result of view.getBehavior(&#x27;thisBehaviorAlias&#x27;).data.toJSON()&gt;
   *       }
   *     }
   *
   * Some Example Configurations:
   *
   * __Static id__ (can be a single String or Number or an array of Strings or Numbers):
   *
   *     View.extend({
   *        behaviors: {
   *          article: {
   *            behavior: require(&#x27;torso/modules/behaviors/DataBehavior&#x27;),
   *            cache: require(&#x27;app/article/articleCacheCollection&#x27;),
   *            returnSingleResult: true,
   *            id: 1234
   *          }
   *        }
   *      });
   *
   *    value used for id: &#x60;1234&#x60;
   *
   *    context for template:
   *
   *     {
   *       ...,
   *       article: {
   *         ...,
   *         data: {
   *           id: 1234,
   *           title: &#x27;A really cool thing&#x27;,
   *           text: &#x27;So I was walking down the street one day...&#x27;
   *         }
   *       }
   *     }
   *
   * __Static ids__ (can be a single String or Number or an array of Strings or Numbers):
   *
   *     View.extend({
   *       behaviors: {
   *         posts: {
   *           behavior: require(&#x27;torso/modules/behaviors/DataBehavior&#x27;),
   *           cache: require(&#x27;app/article/postCacheCollection&#x27;),
   *           ids: [ &#x27;yesterday-by-the-river&#x27;, &#x27;tomorrow-by-the-sea&#x27; ]
   *         }
   *       }
   *     });
   *
   *    value used for ids: &#x60;[ &#x27;yesterday-by-the-river&#x27;, &#x27;tomorrow-by-the-sea&#x27; ]&#x60;
   *
   *    context for template:
   *
   *      {
   *        ...,
   *        posts: {
   *          ...,
   *          data: [{
   *            id: &#x27;yesterday-by-the-river&#x27;,
   *            title: &#x27;Yesterday by the River&#x27;,
   *            author: &#x27;John Smith&#x27;,
   *            content: &#x27;While I was walking by the river...&#x27;
   *          },{
   *            id: &#x27;tomorrow-by-the-sea&#x27;,
   *            title: &#x27;Tomorrow by the Sea&#x27;,
   *            author: &#x27;Mary Smith&#x27;,
   *            content: &#x27;I will walk on the beach tomorrow...&#x27;
   *          }]
   *        }
   *      }
   *
   * __Static id property on view__ (can be a single String or Number or an array of Strings or Numbers):
   *
   *     View.extend({
   *        behaviors: {
   *          article: {
   *            behavior: require(&#x27;torso/modules/behaviors/DataBehavior&#x27;),
   *            cache: require(&#x27;app/article/articleCacheCollection&#x27;),
   *            returnSingleResult: true,
   *            id: { property: &#x27;_articleId&#x27; }
   *          }
   *        }
   *      });
   *
   *    value used for id: &#x60;view._articleId&#x60;
   *
   *    context for template:
   *
   *     {
   *       ...,
   *       article: {
   *         ...,
   *         data: {
   *           id: 12,
   *           title: &#x27;A really cool thing&#x27;,
   *           text: &#x27;So I was walking down the street one day...&#x27;
   *         }
   *       }
   *     }
   *
   * __Static ids property on view__ (can be a single String or Number or an array of Strings or Numbers):
   *
   *     View.extend({
   *       behaviors: {
   *         posts: {
   *           behavior: require(&#x27;torso/modules/behaviors/DataBehavior&#x27;),
   *           cache: require(&#x27;app/article/postCacheCollection&#x27;),
   *           ids: { property: &#x27;_postIds&#x27; }
   *         }
   *       }
   *     });
   *
   *    value used for ids: &#x60;view._postIds&#x60;
   *
   *    context for template:
   *
   *      {
   *        ...,
   *        posts: {
   *          ...,
   *          data: [{
   *            id: &#x27;yesterday-by-the-river&#x27;,
   *            title: &#x27;Yesterday by the River&#x27;,
   *            author: &#x27;John Smith&#x27;,
   *            content: &#x27;While I was walking by the river...&#x27;
   *          },{
   *            id: &#x27;tomorrow-by-the-sea&#x27;,
   *            title: &#x27;Tomorrow by the Sea&#x27;,
   *            author: &#x27;Mary Smith&#x27;,
   *            content: &#x27;I will walk on the beach tomorrow...&#x27;
   *          }]
   *        }
   *      }
   *
   * __
   *
   * @class DataBehavior
   * @method constructor
   * @author  jyoung@vecna.com
   */
  var DataBehavior = Behavior.extend({
    /**
     * The torso collection that is acting as a cache used to create the private collections.
     * This property/option is required.  Instantiation will fail if it is not set.
     * @property cache {Collection}
     */
    cache: undefined,

    /**
     * Determines the result of &#x60;view.getBehavior(&#x27;thisBehaviorAlias&#x27;).toJSON()&#x60;.
     * true - a single model result is returned.
     * false (default) - an array of model results are returned.
     * @property returnSingleResult {Boolean}
     * @default false
     */
    returnSingleResult: false,

    /**
     * Determines whether &#x60;pull()&#x60; or &#x60;fetch()&#x60; is called when using &#x60;retrieve()&#x60;.
     * true - Use fetch() by default on the private collection.
     * false (default) - Use pull() by default on the private collection.
     * True will query the server more often, but will provide more up-to-date data.
     * False will only query the server if the model hasn&#x27;t already been retrieved.
     * This property will be ignored if &#x60;fetch()&#x60; or &#x60;pull()&#x60; is called directly.
     * @property alwaysFetch {Boolean}
     * @default false
     */
    alwaysFetch: false,

    /**
     * Duck-typed property that identifies the ids to use. id or ids is required (either by behavior options or as properties).
     *   - {String|Number} - the id to use directly (equivalent to an array of a single id).
     *   - {String[]|Number[]} - the ids to use directly.
     *   - {Object} - more complex configuration that identifies a model-like object that fires a change event and the
     *                property on that object to use. The object can fire the change event for the given property
     *                and have a .get(&#x27;propertyName&#x27;) method, or it can define the property directly on the context.
     *                Only one property can be identified as supplying the id for this data model.
     *                If the identified object does not fire a change event then the id(s) will never be refreshed for this behavior.
     *                The context can also fire a &#x27;fetched:ids&#x27; event on itself to signal to this data behavior that the ids
     *                have been fetched for the first time.  Then a &#x27;change:&lt;propertyName&gt;&#x27; event can be used to notify this
     *                data behavior that the property has been modified.
     *     - property {String} - the name of the property that defines the ids. The root object is assumed to be the view unless
     *                           context is defined. The context is the object that fires a change event for the given property name.
     *                           Uses the view or the context as the root to get the identified property (i.e. &#x27;viewState.&#x27;, &#x27;model.&#x27;, etc).
     *                           Will get the property before the first &#x27;.&#x27; from the view and if it is an object will try to use a
     *                           .get(&#x27;&lt;propertyName&gt;&#x27;) on it and set a &#x27;change:&lt;propertyName&gt;&#x27; listener on it.
     *                           If it is a string/number or array of string/number, then it will use that as the ids.
     *                           Triggering a &#x27;id-container-updated&#x27; event on the behavior will cause it to stop listing to the
     *                           old context and start listening to the new one defined by this property.
     *     - context {Cell|Backbone.Model|Function} - object (or a function that returns an object) that fires change
     *                           events and has a .get(&#x27;propertyName&#x27;) function. It isn&#x27;t required to fire events -
     *                           the change event is only required if it needs to re-fetch when the id property value changes.
     *     Examples:
     *       - { property: &#x27;_patientId&#x27; }
     *       - { property: &#x27;viewState.appointmentId&#x27; }
     *       - { property: &#x27;model.type&#x27; }
     *       - { property: &#x27;behaviors.demographics.data.appointments&#x27; }
     *       - { property: &#x27;id&#x27;, context: userService }
     *       - { property: &#x27;username&#x27;, context: function() { application.getCurrentUser() } }
     *   - {Function(cache)} - expected to return the ids (either array, jquery deferred that resolves to the ids or single primitive)
     *                         to track with the private collection. Cache is passed in as the first argument so that the behavior
     *                         can be defined and the cache can be overridden later.
     *                         &#x27;this&#x27; is the behavior (from which you can get the view if needed).
     *                         What was criteria should use this instead:
     *
     *         function(cache) {
     *           var thisBehaviorInstance = this;
     *           var view = this.view;
     *           var criteria = { ... some criteria ... };
     *           return cache.fetchIdsByCriteria(criteria);
     *         }
     * @property ids {String|Number|String[]|Number[]|Object|Function}
     */
    ids: undefined,

    /**
     * cause this behavior to re-calculate its ids and refetch them from the server if the given events are triggered
     * (space separated if string, single item is equivalent to array of single item).
     *   - &#x27;view:eventName&#x27; - arbitrary event triggered on the view (eventName can be a change:propertyName event).
     *   - &#x27;viewState:eventName&#x27; - arbitrary event triggered on the viewState (eventName can be a change:propertyName event).
     *   - &#x27;model:eventName&#x27; - arbitrary even triggered on the view&#x27;s model (eventName can be a change:propertyName event).
     *   - &#x27;this:eventName&#x27; - arbitrary event triggered by this behavior (eventName can be a change:propertyName event).
     *   - &#x27;behaviorAlias:eventName&#x27; - arbitrary event triggered by another data behavior on this view (eventName can be a change:propertyName event).
     *   - &#x27;behaviorAlias.data:eventName&#x27; - arbitrary event triggered by the data of another DataBehavior on this view (eventName can be a change:propertyName event).
     *   - { &#x27;&lt;eventName&gt;&#x27;: &lt; object (or function returning an object) that the event is triggered on &gt; } - arbitrary (&#x27;&lt;eventName&gt;&#x27;) triggered on the supplied object.
     * @property updateEvents {String|String[]|Object|Object[]}
     */
    updateEvents: undefined,

    /**
     * Object that manages interaction with the data.  Contains the privateCollection, proxies all events from the privateCollection,
     * and has get(&#x27;...&#x27;) and .toJSON() methods that access the private collection data.
     * @property data {Data}
     */
    data: undefined,

    /**
     * @method constructor
     * @override
     * @param behaviorOptions {Object}
     *   @param behaviorOptions.cache {Collection} see cache property.
     *   @param [behaviorOptions.returnSingleResult=false] {Boolean} see returnSingleResult property.
     *   @param [behaviorOptions.alwaysFetch=false] {Boolean} see alwaysFetch property.
     *   @param [behaviorOptions.id=behaviorOptions.ids] {String|Number|String[]|Number[]|{property: String, context: Object}|Function} see id property.
     *   @param [behaviorOptions.ids=behaviorOptions.id] {String|Number|String[]|Number[]|{property: String, context: Object}|Function} see ids property.
     *   @param [behaviorOptions.updateEvents] {String|String[]|Object|Object[]} see updateEvents property.
     * @param [viewOptions] {Object} options passed to View&#x27;s initialize
     */
    constructor: function(behaviorOptions, viewOptions) {
      _.bindAll(this, &#x27;__fetchSuccess&#x27;, &#x27;__fetchFailed&#x27;);
      behaviorOptions = behaviorOptions || {};
      behaviorOptions = _.defaults(behaviorOptions, {
        alwaysFetch: false
      });
      _.extend(this, _.pick(behaviorOptions, &#x27;cache&#x27;, &#x27;id&#x27;, &#x27;ids&#x27;, &#x27;returnSingleResult&#x27;, &#x27;alwaysFetch&#x27;, &#x27;updateEvents&#x27;));

      this.__validateCache();
      this.__normalizeAndValidateIds();
      this.__normalizeAndValidateUpdateEvents();

      this.cid = this.cid || _.uniqueId(this.cidPrefix);
      /**
       * Private collection that maintains this behavior&#x27;s view of the cache objects.
       * @property data.privateCollection {Collection}
       */
      var privateCollection = this.cache.createPrivateCollection(this.cid);
      this.data = new this.Data({
        parentBehavior: this,
        privateCollection: privateCollection
      });

      Behavior.apply(this, arguments);

      this.on(&#x27;id-container-updated&#x27;, this.listenToIdsPropertyChangeEvent);
      this.on(&#x27;id-container-updated&#x27;, this.retrieve);
      this.listenTo(this.view, &#x27;initialize:complete&#x27;, this.listenToIdsPropertyChangeEvent);
      this.listenTo(this.view, &#x27;initialize:complete&#x27;, this._delegateUpdateEvents);
      this.listenTo(this.view, &#x27;initialize:complete&#x27;, this.retrieve);
    },

    /**
     * Retrieves the ids for this data object and passes them off to the private collection to track and then does a
     * pull or a fetch based on the alwaysFetch property.  (pull is default if always fetch is true then it fetches instead).
     * @method retrieve
     * @return {$.Deferred.Promise} a jquery deferred promise that resolves to the retrieved models.
     */
    retrieve: function() {
      if (this.alwaysFetch) {
        return this.fetch();
      } else {
        return this.pull();
      }
    },

    /**
     * Retrieves the ids for this data object and passes them off to the private collection&#x27;s trackAndPull() method.
     * @method pull
     * @return {$.Deferred.Promise} a jquery deferred promise that resolves to the retrieved models.
     */
    pull: function() {
      var thisDataBehavior = this;
      return this.__getIds()
        .then(function(ids) {
          return thisDataBehavior.data.privateCollection.trackAndPull(ids);
        })
        .then(this.__fetchSuccess, this.__fetchFailed);
    },

    /**
     * Retrieves the ids for this data object and passes them off to the private collection&#x27;s trackAndFetch() method.
     * @method fetch
     * @return {$.Deferred.Promise} a jquery deferred promise that resolves to the retrieved models.
     */
    fetch: function() {
      var thisDataBehavior = this;
      return this.__getIds()
        .then(function(ids) {
          return thisDataBehavior.data.privateCollection.trackAndFetch(ids);
        })
        .then(this.__fetchSuccess, this.__fetchFailed);
    },

    /**
     * Adds the toJSON of the data represented by this behavior to the context.
     * @method prepare
     * @override
     */
    prepare: function() {
      var behaviorContext = Behavior.prototype.prepare.apply(this);
      behaviorContext.data = this.data.toJSON();
      return behaviorContext;
    },

    /**
     * Listens for the change event on the ids property and, if triggered, re-fetches the data based on the new ids.
     * @method listenToIdsPropertyChangeEvent
     */
    listenToIdsPropertyChangeEvent: function() {
      if (!_.isUndefined(this.ids.property)) {
        this.stopListeningToIdsPropertyChangeEvent();
        var idsPropertyNameAndContext = this.__parseIdsPropertyNameAndContext();
        var idsContext = idsPropertyNameAndContext.idsContext;
        var canListenToEvents = idsContext &amp;&amp; _.isFunction(idsContext.on);
        if (canListenToEvents) {
          this.__currentContextWithListener = idsContext;
          this.__currentContextEventName = &#x27;change:&#x27; + idsPropertyNameAndContext.idsPropertyName;
          this.listenTo(this.__currentContextWithListener, this.__currentContextEventName, this.retrieve);
          this.listenTo(this.__currentContextWithListener, &#x27;fetched:ids&#x27;, this.retrieve);
        }
      }
    },

    /**
     * Removes the listener added by listenToIdsPropertyChangeEvent().
     * @method stopListeningToIdsPropertyChangeEvent
     */
    stopListeningToIdsPropertyChangeEvent: function() {
      if (this.__currentContextWithListener) {
        this.stopListening(this.__currentContextWithListener, this.__currentContextEventName, this.retrieve);
        this.stopListening(this.__currentContextWithListener, &#x27;fetched:ids&#x27;, this.retrieve);
        delete this.__currentContextWithListener;
        delete this.__currentContextEventName;
      }
    },

    /**
     * Removes existing listeners and adds new ones for all of the updateEvents configured.
     * @method _delegateUpdateEvents
     * @private
     */
    _delegateUpdateEvents: function() {
      this._undelegateUpdateEvents();
      var updateEvents = this.__parseUpdateEvents();
      _.each(updateEvents, function(parsedUpdateEvent) {
        this.listenTo(parsedUpdateEvent.context, parsedUpdateEvent.eventName, this.retrieve);
      }, this);
    },

    /**
     * Removes existing event listeners.
     * @method _undelegateEvents
     * @private
     */
    _undelegateUpdateEvents: function() {
      var updateEvents = this.__parseUpdateEvents();
      _.each(updateEvents, function(parsedUpdateEvent) {
        this.stopListening(parsedUpdateEvent.context, parsedUpdateEvent.eventName, this.retrieve);
      }, this);
    },

    /**
     * Parses this.updateEvents configuration.
     * @return {[{ eventName: String, context: Object }]} an array of objects with the event name and context included.
     * @private
     */
    __parseUpdateEvents: function() {
      this.__normalizeAndValidateUpdateEvents();
      var updateEvents = _.flatten(_.map(this.updateEvents, this.__parseUpdateEvent, this));
      return _.compact(updateEvents);
    },

    /**
     * Parses an individual event configuration.
     * Note: events defined using objects can have more than one event defined w/in the object.
     * @param updateEventConfiguration {String | Object} the configuration for an individual event configuration.
     * @return {[{ eventName: String, context: Object }] | undefined} an array of objects with the event name and context included.
     *                                                                If the event could not be parsed, undefined is returned.
     * @private
     */
    __parseUpdateEvent: function(updateEventConfiguration) {
      if (_.isUndefined(updateEventConfiguration)) {
        return undefined;
      }
      var parsedUpdateEvents = [];
      if (_.isString(updateEventConfiguration)) {
        var updateEvent = this.__parseStringUpdateEvent(updateEventConfiguration);
        if (!_.isUndefined(updateEvent)) {
          parsedUpdateEvents.push(updateEvent);
        }
      }
      if (_.isObject(updateEventConfiguration)) {
        parsedUpdateEvents = _.map(updateEventConfiguration, function(context, eventName) {
          return {
            context: context,
            eventName: eventName
          };
        });
      }
      return parsedUpdateEvents;
    },

    /**
     * Parse a string type update event.
     * Context Key (first part of the string up to the first &#x27;:&#x27;) can be one of the following:
     *   this (maps to the behavior),
     *   view (maps to the behavior&#x27;s view),
     *   viewState (maps to the behavior&#x27;s view&#x27;s viewState),
     *   model (maps to the behavior&#x27;s view&#x27;s model),
     *   &lt;*&gt; any others are assumed to be the names of behaviors on this behavior&#x27;s view.
     * @param updateEventConfiguration {String} a string representation of the event.
     * @return {{eventName: String, context: Backbone.Events}} the parsed configuration with the event name and context object.
     * @private
     */
    __parseStringUpdateEvent: function(updateEventConfiguration) {
      var contextString = updateEventConfiguration.split(&#x27;:&#x27;, 1)[0];
      var rootContextString = contextString.split(&#x27;.&#x27;, 1)[0];
      var rootContext;
      if (rootContextString === &#x27;this&#x27;) {
        rootContext = this;
      } else if (rootContextString === &#x27;view&#x27;) {
        rootContext = this.view;
      } else if (rootContextString === &#x27;viewState&#x27;) {
        rootContext = this.view.viewState;
      } else if (rootContextString === &#x27;model&#x27;) {
        rootContext = this.view.model;
      } else {
        // assume its a behavior alias.
        rootContext = this.view.getBehavior(rootContextString);
      }
      if (!_.isUndefined(rootContext)) {
        var context = rootContext;
        var contextPropertyString = contextString.replace(rootContextString, &#x27;&#x27;);
        if (contextPropertyString) {
          // remove . in the case that there is a property string.
          contextPropertyString = contextPropertyString.substring(1);
          context = rootContext[contextPropertyString.substring(1)];
        }

        var eventName = updateEventConfiguration.replace(contextString + &#x27;:&#x27;, &#x27;&#x27;);
        return {
          eventName: eventName,
          context: context
        };
      }
    },

    /**
     * Validates that the cache property is valid and if not throws an error describing why its not valid.
     * @method __validateCache
     * @private
     */
    __validateCache: function() {
      if (!this.cache) {
        throw new Error(&#x27;Torso Data Behavior constructed without a cache&#x27;);
      }
      if (!(this.cache instanceof Collection)) {
        throw new Error(&#x27;Torso Data Behavior\&#x27;s cache is not of type Torso.Collection&#x27;);
      }
    },

    /**
     * Validates that the ids property is valid and if not throws an error describing why its not valid.
     * A side effect of this method is copying id into the ids location (if id is set).  Ids is what is used by the rest of the code.
     * This is done as part of validation because we first validate that both are not set.
     * @method __normalizeAndValidateIds
     * @private
     */
    __normalizeAndValidateIds: function() {
      if (!_.isUndefined(this.ids) &amp;&amp; !_.isUndefined(this.id)) {
        throw new Error(&#x27;Torso Data Behavior constructed with both id and ids.  Please define only one.&#x27;);
      }
      this.ids = this.id || this.ids;
      this.__validateIds();
    },

    /**
     * Validates that the ids property is valid and if not throws an error describing why its not valid.
     * A side effect of this method is copying id into the ids location (if id is set).  Ids is what is used by the rest of the code.
     * This is done as part of validation because we first validate that both are not set.
     * @method __normalizeAndValidateIds
     * @private
     */
    __validateIds: function() {
      if (_.isUndefined(this.ids)) {
        throw new Error(&#x27;Torso Data Behavior constructed without a way to identify the ids for this data.  Please define either id, ids.&#x27;);
      }

      var idsIsArray = _.isArray(this.ids);
      var idsIsSingleId = _.isString(this.ids) || _.isNumber(this.ids);
      var idsIsFunction = _.isFunction(this.ids);
      var idsIsObjectWithStringProperty = _.isString(this.ids.property);
      var idsIsObject = _.isObject(this.ids);
      var idsIsValid = idsIsArray || idsIsSingleId || idsIsFunction || idsIsObjectWithStringProperty;
      if (!idsIsValid &amp;&amp; idsIsObject) {
        throw new Error(&#x27;Data Behavior ids invalid definition.  It is an object, but the property field is not defined or is not a string: &#x27; + JSON.stringify(this.ids));
      } else if (!idsIsValid) {
        throw new Error(&#x27;Data Behavior ids invalid definition.  Not a string, number, object, array or function: &#x27; + JSON.stringify(this.ids));
      }
    },

    /**
     * Validates that the updateEvents property is valid and if not throws an error describing why its not valid.
     * @method __normalizeAndValidateUpdateEvents
     * @private
     */
    __normalizeAndValidateUpdateEvents: function() {
      var updateEventsIsArray = _.isArray(this.updateEvents);
      var updateEventsIsSingleValue = !updateEventsIsArray &amp;&amp; (_.isObject(this.updateEvents) || _.isString(this.updateEvents));
      var updateEventsIsUndefined = _.isUndefined(this.updateEvents);
      var updateEventsIsValidType = updateEventsIsArray || updateEventsIsSingleValue || updateEventsIsUndefined;

      if (updateEventsIsSingleValue) {
        this.updateEvents = [this.updateEvents];
      }

      if (!updateEventsIsValidType) {
        throw new Error(&#x27;Update events are not an array, string or object.  Please see parameters for examples of how to define updateEvents.  Configured UpdateEvents: &#x27;, this.updateEvents);
      }

      // Remove any random falsey values (mostly to get rid of undefined events).
      this.updateEvents = _.compact(this.updateEvents);
      _.each(this.updateEvents, this.__validUpdateEvent);
    },

    /**
     * Validates that the updateEventConfiguration is valid and if not throws an error describing why its not valid.
     * @method __normalizeAndValidateIds
     * @private
     */
    __validUpdateEvent: function(updateEventConfiguration) {
      var validStringConfig = _.isString(updateEventConfiguration);
      var validObjectConfig = _.isObject(updateEventConfiguration) &amp;&amp; _.keys(updateEventConfiguration).length &gt; 0;
      if (!validStringConfig &amp;&amp; !validObjectConfig) {
        throw new Error(&#x27;Not a valid updateEvent configuration.  Update events need to either be strings or objects with a single property: &#x27; + JSON.stringify(updateEventConfiguration));
      }
    },

    /**
     * @method __getIds
     * @return {$.Deferred.Promise} a jquery deferred promise that resolves to the ids to track in the private collection
     *                              or rejects with the error message.
     * @private
     */
    __getIds: function() {
      this.__validateIds(); // validate ids enforces a fast-fail that guarantees that one of the if statements below will work.

      var idsDeferred = $.Deferred();
      var ids = this.ids;
      var normalizedIds = normalizeIds(ids);
      if (!_.isUndefined(normalizedIds)) {
        idsDeferred.resolve(normalizedIds);
      } else if (_.isFunction(this.ids)) {
        ids = this.ids(this.cache);
        normalizedIds = normalizeIds(ids);
        if (!_.isUndefined(normalizedIds)) {
          idsDeferred.resolve(normalizedIds);
        } else if (!_.isUndefined(ids) &amp;&amp; _.isFunction(ids.then)) {
          idsDeferred = ids.then(normalizeIds);
        } else {
          idsDeferred.resolve([]);
        }
      } else if (!_.isUndefined(this.ids.property)) {
        var parsedContextDefinition = this.__parseIdsPropertyNameAndContext();
        var propertyName = parsedContextDefinition.idsPropertyName;
        var context = parsedContextDefinition.idsContext;

        ids = context &amp;&amp; context[propertyName];
        var propertyOnContextIsUndefined = context &amp;&amp; _.isUndefined(ids);
        var contextHasGetMethod = context &amp;&amp; _.isFunction(context.get);

        if (propertyOnContextIsUndefined &amp;&amp; contextHasGetMethod) {
          ids = context.get(propertyName);
        }
        normalizedIds = normalizeIds(ids);

        idsDeferred.resolve(normalizedIds || []);
      }
      return idsDeferred.promise();
    },

    /**
     * Converts the definition into the actual context object and property name to retrieve off of that context.
     * @method __parseIdsPropertyNameAndContext
     * @return {{idsPropertyName: String, context: Object}} the name of the ids property and the actual object to use as the context.
     * @private
     */
    __parseIdsPropertyNameAndContext: function() {
      var context = this.__parseIdsContext();

      var propertyName = this.ids.property;

      var propertyParts = propertyName.split(&#x27;.&#x27;);
      var isNestedProperty = propertyParts.length &gt; 1;
      if (isNestedProperty) {
        var rootPropertyName = propertyParts[0];
        if (rootPropertyName === &#x27;behaviors&#x27; || rootPropertyName === &#x27;behavior&#x27;) {
          var behaviorName = propertyParts[1];
          context = this.view.getBehavior(behaviorName);
          if (propertyParts[2] === &#x27;data&#x27;) {
            context = context.data;
            propertyName = propertyParts.slice(3).join(&#x27;.&#x27;);
          } else {
            propertyName = propertyParts.slice(2).join(&#x27;.&#x27;);
          }
        } else if (!_.isUndefined(context[rootPropertyName])) {
          context = context[rootPropertyName];
          propertyName = propertyParts.slice(1).join(&#x27;.&#x27;);
        }
      }

      return {
        idsPropertyName: propertyName,
        idsContext: context
      };
    },

    /**
     * Parses the context property of ids.
     * @return {Object} the context object to apply the properties value to (may not be the final context depending on the property definition).
     * @private
     */
    __parseIdsContext: function() {
      var contextDefinition = this.ids.context;
      var context;
      if (_.isUndefined(contextDefinition)) {
        context = this.view;
      } else if (_.isFunction(contextDefinition)) {
        var contextFxn = _.bind(contextDefinition, this);
        context = contextFxn();
      } else if (_.isString(contextDefinition)) {
        context = _.result(this, contextDefinition);
      } else if (_.isObject(contextDefinition)) {
        context = contextDefinition;
      } else {
        throw new Error(&#x27;Invalid context.  Not a string, object or function: &#x27; + JSON.stringify(this.ids));
      }
      return context;
    },

    /**
     * Triggers a &#x27;fetched&#x27; event with the payload { status: &#x27;success&#x27; } when the fetch completes successfully.
     * @method __fetchSuccess
     * @private
     */
    __fetchSuccess: function() {
      this.trigger(&#x27;fetched&#x27;, { status: &#x27;success&#x27; });
      this.data.trigger(&#x27;fetched&#x27;, { status: &#x27;success&#x27; });
      this.trigger(&#x27;fetched:ids&#x27;);
      this.data.trigger(&#x27;fetched:ids&#x27;);
    },

    /**
     * Triggers a &#x27;fetched&#x27; event with the payload { status: &#x27;failed&#x27; } when the fetch fails.
     * @method __fetchFailed
     * @private
     */
    __fetchFailed: function() {
      this.trigger(&#x27;fetched&#x27;, { status: &#x27;failed&#x27; });
      this.data.trigger(&#x27;fetched&#x27;, { status: &#x27;failed&#x27; });
      this.trigger(&#x27;fetched:ids&#x27;);
      this.data.trigger(&#x27;fetched:ids&#x27;);
    },

    /**
     * Adds listeners when the view is activated.
     * @method _activate
     * @private
     */
    _activate: function() {
      this.listenToIdsPropertyChangeEvent();
      this._delegateUpdateEvents();
      this.data.activate();
    },

    /**
     * Stops listening when the view is deactivated.
     * @method _deactivate
     * @private
     */
    _deactivate: function() {
      this.stopListeningToIdsPropertyChangeEvent();
      this._undelegateUpdateEvents();
      this.data.deactivate();
    },

    /**
     * Default dispose stuff because its not already on behavior.  See https://github.com/vecnatechnologies/backbone-torso/issues/295
     * @method _dispose
     * @private
     */
    _dispose: function() {
      this.data.dispose();

      this.off();
      this.stopListening();
    }
  });

  /**
   * @module Torso.behaviors.DataBehavior
   * @namespace Torso.behaviors.DataBehavior
   */

  /**
   * Data object used to create the .data property of the DataBehavior.
   * @class Data
   * @constructor
   */
  var Data = function(options) {
    this.initialize(options);
  };

  _.extend(Data.prototype, {
    /**
     * Instantiates the data objects and binds it to this behavior instance.
     * @param options {Object} to pass to the initialize methods.
     *   @param options.parentBehavior {DataBehavior} the data behavior instance that this Data object should be bound to.
     *   @param options.privateCollection {Collection} the private collection that this data represents.
     */
    initialize: function(options) {
      _.extend(this, Events);
      /**
       * The dataBehavior instance that owns this data object.
       * @property parentBehavior {DataBehavior}
       */
      this.parentBehavior = options.parentBehavior;
      /**
       * The private collection that this data object manages.
       * @property privateCollection {Collection}
       */
      this.privateCollection = options.privateCollection;
    },

    /**
     * Get the full data object contents.  Either an array if returnSingleResult is false or a single object if it is true.
     * @method toJSON
     * @return {Object} containing the full contents of either the collection or model.
     */
    toJSON: function() {
      var privateCollection = this.privateCollection;
      if (!this.parentBehavior.returnSingleResult) {
        return privateCollection.toJSON();
      }

      if (privateCollection.length === 0) {
        return undefined;
      } else if (privateCollection.length === 1) {
        var singleResultModel = privateCollection.at(0);
        return singleResultModel.toJSON();
      } else {
        throw new Error(&#x27;Multiple results found, but single result expected: &#x27; + JSON.stringify(privateCollection.toJSON()));
      }
    },

    /**
     * Get the full data object contents (either an array of model attributes or a single model attribute based on the
     * value of propertyName) or the value of a specific property if a single result is expected.
     *
     * If returnSingleResult is true then this will return the given property from the model (if that model exists).
     * If returnSingleResult is false then this will return an array containing that property from all of the retrieved models.
     * @method get
     * @param [propertyName] {String} the property to get from the model(s).
     * @return {Object|Object[]} containing the full contents of either the collection or model.
     */
    get: function(propertyName) {
      var privateCollection = this.privateCollection;
      if (!this.parentBehavior.returnSingleResult) {
        if (_.isString(propertyName)) {
          return privateCollection.pluck(propertyName);
        } else {
          return privateCollection.toJSON();
        }
      }

      if (privateCollection.length === 0) {
        return undefined;
      } else if (privateCollection.length === 1) {
        var singleResultModel = privateCollection.at(0);
        if (_.isString(propertyName)) {
          return singleResultModel.get(propertyName);
        }
        return singleResultModel.toJSON();
      } else {
        throw new Error(&#x27;Multiple results found, but single result expected: &#x27; + JSON.stringify(privateCollection.toJSON()));
      }
    },

    /**
     * Adds the listeners to the private collection.
     * @method activate
     */
    activate: function() {
      this.listenTo(this.privateCollection, &#x27;all&#x27;, this.trigger);
    },

    /**
     * Removes the listeners on the private collection.
     * @method deactivate
     */
    deactivate: function() {
      this.stopListening(this.privateCollection, &#x27;all&#x27;, this.trigger);
    },

    /**
     * Dispose of the data events.
     */
    dispose: function() {
      this.off();
      this.stopListening();
    }
  });

  DataBehavior.prototype.Data = Data;

  return DataBehavior;
}));
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
